{"title":"搭建博客第一篇文章测试","uid":"3a556fe55a782df41e9b8696b7c9ddc6","slug":"Test document","date":"2022-09-27T09:34:38.484Z","updated":"2022-09-27T10:23:31.228Z","comments":true,"path":"api/articles/Test document.json","keywords":null,"cover":null,"content":"<p>什么是跨域<br>浏览器有一个重要的安全策略，称之为「同源策略」<br>其中，源&#x3D;协议+主机+端口源&#x3D;协议+主机+端口源&#x3D;协议+主机+端口，两个源相同，称之为同源，两个源不同，称之为跨源或跨域<br>比如：</p>\n<p>源 1源 2是否同源<a href=\"http://www.baidu.comwww.baidu.com/news%E2%9C%85www.baidu.comwww.baidu.com%E2%9D%8Chttp://localhost:5000http://localhost:7000%E2%9D%8Chttp://localhost:5000http://127.0.0.1:5000%E2%9D%8Cwww.baidu.combaidu.com%E2%9D%8C\">www.baidu.comwww.baidu.com/news✅www.baidu.comwww.baidu.com❌http://localhost:5000http://localhost:7000❌http://localhost:5000http://127.0.0.1:5000❌www.baidu.combaidu.com❌</a><br>同源策略是指，若页面的源和页面运行过程中加载的源不一致时，出于安全考虑，浏览器会对跨域的资源访问进行一些限制</p>\n<p>同源策略对 ajax 的跨域限制的最为凶狠，默认情况下，它不允许 ajax 访问跨域资源</p>\n<p>所以，我们通常所说的跨域问题，就是同源策略对 ajax 产生的影响<br>有多种方式解决跨域问题，常见的有：</p>\n<p>代理，常用<br>CORS，常用<br>JSONP</p>\n<p>无论使用哪一种方式，都是要让浏览器知道，我这次跨域请求的是自己人，就不要拦截了。<br>跨域解决方法1-代理<br>对于前端开发而言，大部分的跨域问题，都是通过代理解决的<br>代理适用的场景是：生产环境不发生跨域，但开发环境发生跨域<br>因此，只需要在开发环境使用代理解决跨域即可，这种代理又称之为开发代理</p>\n<p>在实际开发中，只需要对开发服务器稍加配置即可完成<br>&#x2F;&#x2F; vue 的开发服务器代理配置<br>&#x2F;&#x2F; vue.config.js<br>module.exports &#x3D; {<br>  devServer: { &#x2F;&#x2F; 配置开发服务器<br>    proxy: { &#x2F;&#x2F; 配置代理<br>      “&#x2F;api”: { &#x2F;&#x2F; 若请求路径以 &#x2F;api 开头<br>        target: “<a href=\"http://dev.taobao.com&quot;/\">http://dev.taobao.com&quot;</a>, &#x2F;&#x2F; 将其转发到 <a href=\"http://dev.taobao.com/\">http://dev.taobao.com</a><br>      },<br>    },<br>  },<br>};<br>复制代码<br>跨域解决方法2-JSONP<br>在CORS出现之前，人们想了一种奇妙的办法来实现跨域，这就是JSONP。<br>要实现JSONP，需要浏览器和服务器来一个天衣无缝的绝妙配合。<br>JSONP的做法是：当需要跨域请求时，不使用AJAX，转而生成一个script元素去请求服务器，由于浏览器并不阻止script元素的请求，这样请求可以到达服务器。服务器拿到请求后，响应一段JS代码，这段代码实际上是一个函数调用，调用的是客户端预先生成好的函数，并把浏览器需要的数据作为参数传递到函数中，从而间接的把数据传递给客户端</p>\n<p>JSONP有着明显的缺点，即其只能支持GET请求<br>跨域解决方法3-CORS<br>概述<br>CORS是基于http1.1的一种跨域解决方案，它的全称是Cross-Origin Resource Sharing，跨域资源共享。<br>它的总体思路是：如果浏览器要跨域访问服务器的资源，需要获得服务器的允许</p>\n<p>而要知道，一个请求可以附带很多信息，从而会对服务器造成不同程度的影响<br>比如有的请求只是获取一些新闻，有的请求会改动服务器的数据<br>针对不同的请求，CORS 规定了三种不同的交互模式，分别是：</p>\n<p>简单请求<br>需要预检的请求<br>附带身份凭证的请求</p>\n<p>这三种模式从上到下层层递进，请求可以做的事越来越多，要求也越来越严格。<br>下面分别说明三种请求模式的具体规范。<br>简单请求<br>当浏览器端运行了一段 ajax 代码（无论是使用 XMLHttpRequest 还是 fetch api），浏览器会首先判断它属于哪一种请求模式<br>简单请求的判定<br>当请求同时满足以下条件时，浏览器会认为它是一个简单请求：</p>\n<p>请求方法属于下面的一种：</p>\n<p>get<br>post<br>head</p>\n<p>请求头仅包含安全的字段，常见的安全字段如下：</p>\n<p>Accept<br>Accept-Language<br>Content-Language<br>Content-Type<br>DPR<br>Downlink<br>Save-Data<br>Viewport-Width<br>Width</p>\n<p>请求头如果包含Content-Type，仅限下面的值之一：</p>\n<p>text&#x2F;plain<br>multipart&#x2F;form-data<br>application&#x2F;x-www-form-urlencoded</p>\n<p>如果以上三个条件同时满足，浏览器判定为简单请求。<br>下面是一些例子：<br>&#x2F;&#x2F; 简单请求<br>fetch(‘<a href=\"http://crossdomain.com/api/news&#39;\">http://crossdomain.com/api/news&#39;</a>);</p>\n<p>&#x2F;&#x2F; 请求方法不满足要求，不是简单请求<br>fetch(‘<a href=\"http://crossdomain.com/api/news&#39;\">http://crossdomain.com/api/news&#39;</a>, {<br>  method: ‘PUT’,<br>});</p>\n<p>&#x2F;&#x2F; 加入了额外的请求头，不是简单请求<br>fetch(‘<a href=\"http://crossdomain.com/api/news&#39;\">http://crossdomain.com/api/news&#39;</a>, {<br>  headers: {<br>    a: 1,<br>  },<br>});</p>\n<p>&#x2F;&#x2F; 简单请求<br>fetch(‘<a href=\"http://crossdomain.com/api/news&#39;\">http://crossdomain.com/api/news&#39;</a>, {<br>  method: ‘post’,<br>});</p>\n<p>&#x2F;&#x2F; content-type不满足要求，不是简单请求<br>fetch(‘<a href=\"http://crossdomain.com/api/news&#39;\">http://crossdomain.com/api/news&#39;</a>, {<br>  method: ‘post’,<br>  headers: {<br>    ‘content-type’: ‘application&#x2F;json’,<br>  },<br>});<br>复制代码<br>简单请求的交互规范<br>当浏览器判定某个ajax 跨域请求是简单请求时，会发生以下的事情</p>\n<p>请求头中会自动添加Origin字段</p>\n<p>比如，在页面<a href=\"http://my.com/index.html%E4%B8%AD%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E9%80%A0%E6%88%90%E4%BA%86%E8%B7%A8%E5%9F%9F\">http://my.com/index.html中有以下代码造成了跨域</a><br>&#x2F;&#x2F; 简单请求<br>fetch(‘<a href=\"http://crossdomain.com/api/news&#39;\">http://crossdomain.com/api/news&#39;</a>);<br>复制代码<br>请求发出后，请求头会是下面的格式：<br>GET &#x2F;api&#x2F;news&#x2F; HTTP&#x2F;1.1<br>Host: crossdomain.com<br>Connection: keep-alive<br>…<br>Referer: <a href=\"http://my.com/index.html\">http://my.com/index.html</a><br>Origin: <a href=\"http://my.com/\">http://my.com</a><br>复制代码<br>看到最后一行没，Origin字段会告诉服务器，是哪个源地址在跨域请求</p>\n<p>服务器响应头中应包含Access-Control-Allow-Origin</p>\n<p>当服务器收到请求后，如果允许该请求跨域访问，需要在响应头中添加Access-Control-Allow-Origin字段<br>该字段的值可以是：</p>\n<p>*：表示我很开放，什么人我都允许访问<br>具体的源：比如<a href=\"http://my.com,表示我就允许你访问/\">http://my.com，表示我就允许你访问</a></p>\n<p>实际上，这两个值对于客户端<a href=\"http://my.com而言,都一样,因为客户端才不会管其他源服务器允不允许,就关心自己是否被允许/\">http://my.com而言，都一样，因为客户端才不会管其他源服务器允不允许，就关心自己是否被允许</a><br>当然，服务器也可以维护一个可被允许的源列表，如果请求的Origin命中该列表，才响应*或具体的源<br>为了避免后续的麻烦，强烈推荐响应具体的源</p>\n<p>假设服务器做出了以下的响应：<br>HTTP&#x2F;1.1 200 OK<br>Date: Tue, 21 Apr 2020 08:03:35 GMT<br>…<br>Access-Control-Allow-Origin: <a href=\"http://my.com/\">http://my.com</a><br>…</p>\n<p>消息体中的数据<br>复制代码<br>当浏览器看到服务器允许自己访问后，高兴的像一个两百斤的孩子，于是，它就把响应顺利的交给 js，以完成后续的操作<br>下图简述了整个交互过程</p>\n<p>需要预检的请求<br>简单的请求对服务器的威胁不大，所以允许使用上述的简单交互即可完成。<br>但是，如果浏览器不认为这是一种简单请求，就会按照下面的流程进行：</p>\n<p>浏览器发送预检请求，询问服务器是否允许<br>服务器允许<br>浏览器发送真实请求<br>服务器完成真实的响应</p>\n<p>比如，在页面<a href=\"http://my.com/index.html%E4%B8%AD%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E9%80%A0%E6%88%90%E4%BA%86%E8%B7%A8%E5%9F%9F\">http://my.com/index.html中有以下代码造成了跨域</a><br>&#x2F;&#x2F; 需要预检的请求<br>fetch(‘<a href=\"http://crossdomain.com/api/user&#39;\">http://crossdomain.com/api/user&#39;</a>, {<br>  method: ‘POST’, &#x2F;&#x2F; post 请求<br>  headers: {<br>    &#x2F;&#x2F; 设置请求头<br>    a: 1,<br>    b: 2,<br>    ‘content-type’: ‘application&#x2F;json’,<br>  },<br>  body: JSON.stringify({ name: ‘袁小进’, age: 18 }), &#x2F;&#x2F; 设置请求体<br>});<br>复制代码<br>浏览器发现它不是一个简单请求，则会按照下面的流程与服务器交互</p>\n<p>浏览器发送预检请求，询问服务器是否允许</p>\n<p>OPTIONS &#x2F;api&#x2F;user HTTP&#x2F;1.1<br>Host: crossdomain.com<br>…<br>Origin: <a href=\"http://my.com/\">http://my.com</a><br>Access-Control-Request-Method: POST<br>Access-Control-Request-Headers: a, b, content-type<br>复制代码<br>可以看出，这并非我们想要发出的真实请求，请求中不包含我们的请求头，也没有消息体。<br>这是一个预检请求，它的目的是询问服务器，是否允许后续的真实请求。<br>预检请求没有请求体，它包含了后续真实请求要做的事情<br>预检请求有以下特征：</p>\n<p>请求方法为OPTIONS<br>没有请求体<br>请求头中包含</p>\n<p>Origin：请求的源，和简单请求的含义一致<br>Access-Control-Request-Method：后续的真实请求将使用的请求方法<br>Access-Control-Request-Headers：后续的真实请求会改动的请求头</p>\n<p>服务器允许</p>\n<p>服务器收到预检请求后，可以检查预检请求中包含的信息，如果允许这样的请求，需要响应下面的消息格式<br>HTTP&#x2F;1.1 200 OK<br>Date: Tue, 21 Apr 2020 08:03:35 GMT<br>…<br>Access-Control-Allow-Origin: <a href=\"http://my.com/\">http://my.com</a><br>Access-Control-Allow-Methods: POST<br>Access-Control-Allow-Headers: a, b, content-type<br>Access-Control-Max-Age: 86400<br>…<br>复制代码<br>对于预检请求，不需要响应任何的消息体，只需要在响应头中添加：</p>\n<p>Access-Control-Allow-Origin：和简单请求一样，表示允许的源<br>Access-Control-Allow-Methods：表示允许的后续真实的请求方法<br>Access-Control-Allow-Headers：表示允许改动的请求头<br>Access-Control-Max-Age：告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了</p>\n<p>浏览器发送真实请求</p>\n<p>预检被服务器允许后，浏览器就会发送真实请求了，上面的代码会发生下面的请求数据<br>POST &#x2F;api&#x2F;user HTTP&#x2F;1.1<br>Host: crossdomain.com<br>Connection: keep-alive<br>…<br>Referer: <a href=\"http://my.com/index.html\">http://my.com/index.html</a><br>Origin: <a href=\"http://my.com/\">http://my.com</a></p>\n<p>{“name”: “xiaoming”, “age”: 18 }<br>复制代码</p>\n<p>服务器响应真实请求</p>\n<p>HTTP&#x2F;1.1 200 OK<br>Date: Tue, 21 Apr 2020 08:03:35 GMT<br>…<br>Access-Control-Allow-Origin: <a href=\"http://my.com/\">http://my.com</a><br>…</p>\n<p>添加用户成功<br>复制代码<br>可以看出，当完成预检之后，后续的处理与简单请求相同<br>下图简述了整个交互过程</p>\n<p>附带身份凭证的请求<br>默认情况下，ajax 的跨域请求并不会附带 cookie，这样一来，某些需要权限的操作就无法进行<br>不过可以通过简单的配置就可以实现附带 cookie<br>&#x2F;&#x2F; xhr<br>var xhr &#x3D; new XMLHttpRequest();<br>xhr.withCredentials &#x3D; true;</p>\n<p>&#x2F;&#x2F; fetch api<br>fetch(url, {<br>  credentials: ‘include’,<br>});<br>复制代码<br>这样一来，该跨域的 ajax 请求就是一个附带身份凭证的请求<br>当一个请求需要附带 cookie 时，无论它是简单请求，还是预检请求，都会在请求头中添加cookie字段<br>而服务器响应时，需要明确告知客户端：服务器允许这样的凭据<br>告知的方式也非常的简单，只需要在响应头中添加：Access-Control-Allow-Credentials: true即可<br>对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝。<br>另外要特别注意的是：对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为<em>。这就是为什么不推荐使用</em>的原因<br>一个额外的补充<br>在跨域访问时，JS 只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。<br>Access-Control-Expose-Headers头让服务器把允许浏览器访问的头放入白名单，例如：</p>\n<p>作者：一只前端小菜鸟<br>链接：<a href=\"https://juejin.cn/post/7094162429310926855\">https://juejin.cn/post/7094162429310926855</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n","text":"什么是跨域浏览器有一个重要的安全策略，称之为「同源策略」其中，源&#x3D;协议+主机+端口源&#x3D;协议+主机+端口源&#x3D;协议+主机+端口，两个源相同，称之为同源，两个源不同，称之为跨源或跨域比如： 源 1源 2是否同源www.baidu.comwww.baidu....","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[],"tags":[],"toc":"","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{}}