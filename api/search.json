[{"id":"3a556fe55a782df41e9b8696b7c9ddc6","title":"搭建博客第一篇文章测试","content":"什么是跨域浏览器有一个重要的安全策略，称之为「同源策略」其中，源&#x3D;协议+主机+端口源&#x3D;协议+主机+端口源&#x3D;协议+主机+端口，两个源相同，称之为同源，两个源不同，称之为跨源或跨域比如：\n源 1源 2是否同源www.baidu.comwww.baidu.com/news✅www.baidu.comwww.baidu.com❌http://localhost:5000http://localhost:7000❌http://localhost:5000http://127.0.0.1:5000❌www.baidu.combaidu.com❌同源策略是指，若页面的源和页面运行过程中加载的源不一致时，出于安全考虑，浏览器会对跨域的资源访问进行一些限制\n同源策略对 ajax 的跨域限制的最为凶狠，默认情况下，它不允许 ajax 访问跨域资源\n所以，我们通常所说的跨域问题，就是同源策略对 ajax 产生的影响有多种方式解决跨域问题，常见的有：\n代理，常用CORS，常用JSONP\n无论使用哪一种方式，都是要让浏览器知道，我这次跨域请求的是自己人，就不要拦截了。跨域解决方法1-代理对于前端开发而言，大部分的跨域问题，都是通过代理解决的代理适用的场景是：生产环境不发生跨域，但开发环境发生跨域因此，只需要在开发环境使用代理解决跨域即可，这种代理又称之为开发代理\n在实际开发中，只需要对开发服务器稍加配置即可完成&#x2F;&#x2F; vue 的开发服务器代理配置&#x2F;&#x2F; vue.config.jsmodule.exports &#x3D; {  devServer: { &#x2F;&#x2F; 配置开发服务器    proxy: { &#x2F;&#x2F; 配置代理      “&#x2F;api”: { &#x2F;&#x2F; 若请求路径以 &#x2F;api 开头        target: “http://dev.taobao.com&quot;, &#x2F;&#x2F; 将其转发到 http://dev.taobao.com      },    },  },};复制代码跨域解决方法2-JSONP在CORS出现之前，人们想了一种奇妙的办法来实现跨域，这就是JSONP。要实现JSONP，需要浏览器和服务器来一个天衣无缝的绝妙配合。JSONP的做法是：当需要跨域请求时，不使用AJAX，转而生成一个script元素去请求服务器，由于浏览器并不阻止script元素的请求，这样请求可以到达服务器。服务器拿到请求后，响应一段JS代码，这段代码实际上是一个函数调用，调用的是客户端预先生成好的函数，并把浏览器需要的数据作为参数传递到函数中，从而间接的把数据传递给客户端\nJSONP有着明显的缺点，即其只能支持GET请求跨域解决方法3-CORS概述CORS是基于http1.1的一种跨域解决方案，它的全称是Cross-Origin Resource Sharing，跨域资源共享。它的总体思路是：如果浏览器要跨域访问服务器的资源，需要获得服务器的允许\n而要知道，一个请求可以附带很多信息，从而会对服务器造成不同程度的影响比如有的请求只是获取一些新闻，有的请求会改动服务器的数据针对不同的请求，CORS 规定了三种不同的交互模式，分别是：\n简单请求需要预检的请求附带身份凭证的请求\n这三种模式从上到下层层递进，请求可以做的事越来越多，要求也越来越严格。下面分别说明三种请求模式的具体规范。简单请求当浏览器端运行了一段 ajax 代码（无论是使用 XMLHttpRequest 还是 fetch api），浏览器会首先判断它属于哪一种请求模式简单请求的判定当请求同时满足以下条件时，浏览器会认为它是一个简单请求：\n请求方法属于下面的一种：\ngetposthead\n请求头仅包含安全的字段，常见的安全字段如下：\nAcceptAccept-LanguageContent-LanguageContent-TypeDPRDownlinkSave-DataViewport-WidthWidth\n请求头如果包含Content-Type，仅限下面的值之一：\ntext&#x2F;plainmultipart&#x2F;form-dataapplication&#x2F;x-www-form-urlencoded\n如果以上三个条件同时满足，浏览器判定为简单请求。下面是一些例子：&#x2F;&#x2F; 简单请求fetch(‘http://crossdomain.com/api/news&#39;);\n&#x2F;&#x2F; 请求方法不满足要求，不是简单请求fetch(‘http://crossdomain.com/api/news&#39;, {  method: ‘PUT’,});\n&#x2F;&#x2F; 加入了额外的请求头，不是简单请求fetch(‘http://crossdomain.com/api/news&#39;, {  headers: {    a: 1,  },});\n&#x2F;&#x2F; 简单请求fetch(‘http://crossdomain.com/api/news&#39;, {  method: ‘post’,});\n&#x2F;&#x2F; content-type不满足要求，不是简单请求fetch(‘http://crossdomain.com/api/news&#39;, {  method: ‘post’,  headers: {    ‘content-type’: ‘application&#x2F;json’,  },});复制代码简单请求的交互规范当浏览器判定某个ajax 跨域请求是简单请求时，会发生以下的事情\n请求头中会自动添加Origin字段\n比如，在页面http://my.com/index.html中有以下代码造成了跨域&#x2F;&#x2F; 简单请求fetch(‘http://crossdomain.com/api/news&#39;);复制代码请求发出后，请求头会是下面的格式：GET &#x2F;api&#x2F;news&#x2F; HTTP&#x2F;1.1Host: crossdomain.comConnection: keep-alive…Referer: http://my.com/index.htmlOrigin: http://my.com复制代码看到最后一行没，Origin字段会告诉服务器，是哪个源地址在跨域请求\n服务器响应头中应包含Access-Control-Allow-Origin\n当服务器收到请求后，如果允许该请求跨域访问，需要在响应头中添加Access-Control-Allow-Origin字段该字段的值可以是：\n*：表示我很开放，什么人我都允许访问具体的源：比如http://my.com，表示我就允许你访问\n实际上，这两个值对于客户端http://my.com而言，都一样，因为客户端才不会管其他源服务器允不允许，就关心自己是否被允许当然，服务器也可以维护一个可被允许的源列表，如果请求的Origin命中该列表，才响应*或具体的源为了避免后续的麻烦，强烈推荐响应具体的源\n假设服务器做出了以下的响应：HTTP&#x2F;1.1 200 OKDate: Tue, 21 Apr 2020 08:03:35 GMT…Access-Control-Allow-Origin: http://my.com…\n消息体中的数据复制代码当浏览器看到服务器允许自己访问后，高兴的像一个两百斤的孩子，于是，它就把响应顺利的交给 js，以完成后续的操作下图简述了整个交互过程\n需要预检的请求简单的请求对服务器的威胁不大，所以允许使用上述的简单交互即可完成。但是，如果浏览器不认为这是一种简单请求，就会按照下面的流程进行：\n浏览器发送预检请求，询问服务器是否允许服务器允许浏览器发送真实请求服务器完成真实的响应\n比如，在页面http://my.com/index.html中有以下代码造成了跨域&#x2F;&#x2F; 需要预检的请求fetch(‘http://crossdomain.com/api/user&#39;, {  method: ‘POST’, &#x2F;&#x2F; post 请求  headers: {    &#x2F;&#x2F; 设置请求头    a: 1,    b: 2,    ‘content-type’: ‘application&#x2F;json’,  },  body: JSON.stringify({ name: ‘袁小进’, age: 18 }), &#x2F;&#x2F; 设置请求体});复制代码浏览器发现它不是一个简单请求，则会按照下面的流程与服务器交互\n浏览器发送预检请求，询问服务器是否允许\nOPTIONS &#x2F;api&#x2F;user HTTP&#x2F;1.1Host: crossdomain.com…Origin: http://my.comAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: a, b, content-type复制代码可以看出，这并非我们想要发出的真实请求，请求中不包含我们的请求头，也没有消息体。这是一个预检请求，它的目的是询问服务器，是否允许后续的真实请求。预检请求没有请求体，它包含了后续真实请求要做的事情预检请求有以下特征：\n请求方法为OPTIONS没有请求体请求头中包含\nOrigin：请求的源，和简单请求的含义一致Access-Control-Request-Method：后续的真实请求将使用的请求方法Access-Control-Request-Headers：后续的真实请求会改动的请求头\n服务器允许\n服务器收到预检请求后，可以检查预检请求中包含的信息，如果允许这样的请求，需要响应下面的消息格式HTTP&#x2F;1.1 200 OKDate: Tue, 21 Apr 2020 08:03:35 GMT…Access-Control-Allow-Origin: http://my.comAccess-Control-Allow-Methods: POSTAccess-Control-Allow-Headers: a, b, content-typeAccess-Control-Max-Age: 86400…复制代码对于预检请求，不需要响应任何的消息体，只需要在响应头中添加：\nAccess-Control-Allow-Origin：和简单请求一样，表示允许的源Access-Control-Allow-Methods：表示允许的后续真实的请求方法Access-Control-Allow-Headers：表示允许改动的请求头Access-Control-Max-Age：告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了\n浏览器发送真实请求\n预检被服务器允许后，浏览器就会发送真实请求了，上面的代码会发生下面的请求数据POST &#x2F;api&#x2F;user HTTP&#x2F;1.1Host: crossdomain.comConnection: keep-alive…Referer: http://my.com/index.htmlOrigin: http://my.com\n{“name”: “xiaoming”, “age”: 18 }复制代码\n服务器响应真实请求\nHTTP&#x2F;1.1 200 OKDate: Tue, 21 Apr 2020 08:03:35 GMT…Access-Control-Allow-Origin: http://my.com…\n添加用户成功复制代码可以看出，当完成预检之后，后续的处理与简单请求相同下图简述了整个交互过程\n附带身份凭证的请求默认情况下，ajax 的跨域请求并不会附带 cookie，这样一来，某些需要权限的操作就无法进行不过可以通过简单的配置就可以实现附带 cookie&#x2F;&#x2F; xhrvar xhr &#x3D; new XMLHttpRequest();xhr.withCredentials &#x3D; true;\n&#x2F;&#x2F; fetch apifetch(url, {  credentials: ‘include’,});复制代码这样一来，该跨域的 ajax 请求就是一个附带身份凭证的请求当一个请求需要附带 cookie 时，无论它是简单请求，还是预检请求，都会在请求头中添加cookie字段而服务器响应时，需要明确告知客户端：服务器允许这样的凭据告知的方式也非常的简单，只需要在响应头中添加：Access-Control-Allow-Credentials: true即可对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝。另外要特别注意的是：对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为。这就是为什么不推荐使用的原因一个额外的补充在跨域访问时，JS 只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。Access-Control-Expose-Headers头让服务器把允许浏览器访问的头放入白名单，例如：\n作者：一只前端小菜鸟链接：https://juejin.cn/post/7094162429310926855来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","slug":"Test document","date":"2022-09-27T09:34:38.484Z","categories_index":"","tags_index":"","author_index":"TheV21"}]